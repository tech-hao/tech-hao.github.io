<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>计算机网络笔记(3)——传输层</title>
    <link href="/2023/10/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0-3-%E2%80%94%E2%80%94%E4%BC%A0%E8%BE%93%E5%B1%82/"/>
    <url>/2023/10/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0-3-%E2%80%94%E2%80%94%E4%BC%A0%E8%BE%93%E5%B1%82/</url>
    
    <content type="html"><![CDATA[<h1 id="传输层服务概述">1.传输层服务概述</h1><ul><li>传输层协议为运行在不同Host上的进程提供了一种端到端的逻辑通信机制。<ul><li>发送方：将应用递交的信息分成一个或多个报文段，并向下传给网络层</li><li>接收方：将接收到的报文段组装成消息，并向上递交给应用层</li></ul></li></ul><h2 id="传输层-vs.-网络层">1.1 传输层 vs. 网络层</h2><ul><li>网络层：提供主机之间的逻辑通信机制</li><li>传输层：提供应用进程之间的逻辑通信机制<ul><li>位于网络层之上，依赖于网络层服务</li><li>对网络层服务进行（可能的）增强</li></ul></li></ul><h2 id="internet的传输层协议">1.2 Internet的传输层协议</h2><ul><li>TCP协议<ul><li>可靠的、按序的交付服务</li><li>拥塞控制</li><li>流量控制</li><li>面向连接</li></ul></li><li>UDP协议<ul><li>不可靠的交付服务</li><li>基于“尽力而为交付服务”的网络层，没有做可靠性方面的扩展</li></ul></li></ul><h1 id="多路复用和多路分用">2.多路复用和多路分用</h1><ul><li>多路复用：在源主机从不同套接字中收集数据块，并为每个数据块封装上首部信息，从而生成报文段，然后将报文段传递到网络层，所有这些工作称之为多路复用</li><li>多路分用：将运输层报文段中的数据交付到正确的套接字称为多路分用<ul><li>多路分用工作流程<ul><li>主机接受到IP数据报<ul><li>每个数据报携带源IP地址、目的IP地址</li><li>每个数据报携带一个传输层的段（Segment），每个段携带源端口号和目的端口号</li></ul></li><li>主机收到报文段后，传输层协议提取IP地址和端口号信息，将报文段导向相应的套接字</li></ul></li></ul></li><li>无连接多路分用<ul><li>利用端口号创建套接字<ul><li>UDP的套接字用二元组标识：（目的IP地址，目的端口号）</li></ul></li><li>主机收到UDP段后<ul><li>检查段中的目的端口号</li><li>将UDP段导向绑定在该端口号的套接字</li></ul></li></ul></li></ul><blockquote><p>注：来自不同源IP地址或源端口号的IP数据报可以被导向同一个套接字</p></blockquote><ul><li>面向连接的多路分用 vs. 无连接多路复用<ul><li>TCP的套接字用四元组标识<ul><li>源IP地址</li><li>源端口号</li><li>目的IP地址</li><li>目的端口号</li></ul></li><li>服务器可能同时支持多个TCP套接字<ul><li>Web服务器为每个客户端开不同的套接字</li></ul></li></ul></li></ul><blockquote><p>TCP连接只能由一个客户机进程导向一个服务器进程，反之亦然。故来自不同源IP地址或源端口号的数据报不可能被导向同一个套接字</p></blockquote><h1 id="udp协议user-datagram-protocol">3.UDP协议（User DatagramProtocol）</h1><ul><li>实现多路复用/分用与简单的错误校验</li><li>基于“尽力而为交付服务”，UDP段可能丢失或非按序到达</li><li>无需建立连接<ul><li>UDP发送方和接收方之间不需要握手</li><li>每个UDP段的处理独立于其他段</li><li>显著减少延迟</li></ul></li><li>无需维护连接状态，实现简单</li><li>分组头部开销少</li><li>没有拥塞控制，应用可以更好地控制发送时间和速率</li><li>UDP报文段格式 <imgsrc="https://s2.loli.net/2023/10/03/qxvEj7b54UGgi8M.png" /></li></ul><h2 id="udp校验和">3.1 UDP校验和</h2><ul><li>检验和用于确定当UDP报文段从源到达目的地移动时，其中的比特是否发生了改变</li><li>校验和计算：发送方将所有16比特字的和进行计算，进位加在和的后面，将得到的值按位求反，得到校验和，放入UDP报文的校验和字段（checksum）</li><li>接收方计算所收到段的校验和，将其与校验和字段进行对比<ul><li>不相等：检测出错误</li><li>相等：检测出错误</li></ul></li></ul><h1 id="可靠数据传输原理">4.可靠数据传输原理</h1><ul><li>可靠数据传输保证数据从发送端到接收端内容不错、不丢包、顺序不乱 <imgsrc="https://s2.loli.net/2023/10/03/4opsTX7yqLUZjY1.jpg" /></li><li>利用状态机（Finite State Machine,FSM）刻画传输协议<ul><li>圆圈代表发送方或接受方的状态</li><li>箭头代表状态的转换</li><li>横线上面的函数表示引起变迁的事件，横线下面的函数代表事件发生时所采取的操作<ul><li>若进行状态转换不必进行其他操作，则用^表示</li></ul></li></ul></li></ul><h2 id="rdt-1.0">4.1 Rdt 1.0：</h2><p><img src="https://s2.loli.net/2023/10/03/MhiQGTmRgnqNF2K.jpg" /></p><h2 id="rdt-2.0具有比特差错信道的可靠数据传输">4.2 Rdt2.0：具有比特差错信道的可靠数据传输</h2><ul><li>底层信道中传输的数据可能发生位错误，故需要引入如下功能完善协议<ul><li>差错检测：提供一种机制使得接收方检测到比特差错</li><li>接收方反馈：提供一种确认机制，使得接收方可以显式告诉发送方分组正确接收。rdt2.0协议将从接收方向发送方发送肯定确认分组（ACK）和否定分组（NAK）</li><li>重传：发送方收到NAK后，重传分组 <imgsrc="https://s2.loli.net/2023/10/03/dcMItSmv8XK7AZ9.jpg" /></li></ul></li></ul><h2 id="rdt-2.1">4.3 Rdt 2.1</h2><ul><li>Rdt 2.0协议存在缺陷——未考虑ACK/NAK消息被破坏的现象<ul><li>为ACK、NAK添加校验和，检错纠错。接收方不知道ACK/NAK是否正确被发送方收到</li><li>如果ACK/NAK坏掉，发送方重传。但存在接收方存在重复分组的可能<ul><li>引入序列号（sequence number），让发送方对其数据分组添加序列号</li><li>接收方丢弃序列号重复的分组 发送方的FSM描述见下图 <imgsrc="https://s2.loli.net/2023/10/03/Uwz2qKhBW1EHpf3.jpg" />接收方的FSM见下图 <imgsrc="https://s2.loli.net/2023/10/03/BvjfCo3DRAi9PlY.jpg" /></li></ul></li></ul></li></ul><h2 id="rdt-2.2无nak消息协议">4.4 Rdt 2.2：无NAK消息协议</h2><ul><li>在Rdt 2.1的基础上，只使用ACK<ul><li>接收方通过ACK告知最后一个被正确接收的分组</li><li>在ACK消息中显式地加入被确认分组的序列号</li><li>若收到带有重复序列号的ACK，则重传当前分组</li></ul></li></ul><h2 id="rdt-3.0">4.5 Rdt 3.0</h2><ul><li>Rdt 2.0没有考虑信道丢包的问题</li><li>设置<strong>定时器</strong>，发送方等待一段时间<ul><li>如果在这段时间内没收到ACK，发送方重传分组</li><li>如果分组或ACK在定时器终止之后到达<ul><li>会导致发送方重传分组，利用序列号机制处理冗余数据分组</li><li>接收方在ACK中显式告知所确认的分组 发送方FSM如下图所示 <imgsrc="https://s2.loli.net/2023/10/03/f4lThBQrxpHSudj.jpg" /> Rdt3.0示例如下图所示 <imgsrc="https://s2.loli.net/2023/10/03/QjmTK453UMbG9ov.jpg" /> <imgsrc="https://s2.loli.net/2023/10/03/I7cRPLyCzY4VKqx.jpg" /></li></ul></li></ul></li></ul><h2 id="流水线可靠数据传输协议">4.6 流水线可靠数据传输协议</h2><ul><li><p>Rdt 3.0协议功能正确，但性能糟糕</p><ul><li>对于一条发送速率为1Gbps的链路，假定往返传播时延RTT为30ms，利用Rdt3.0协议发送一个1000B的分组，则发送方的信道利用率仅为： <spanclass="math display">\[U_{sender} =  \frac{L/R}{RTT+L/R} = \frac{0.008}{30.008} = 0.00027\]</span></li></ul></li><li><p>解决上述低效的性能问题的方法：不以停等方式运行，允许发送方发送多个分组无需等待确认。这种技术也称为流水线技术。利用此技术，可靠数据传输协议需要：</p><ul><li>增加序列号范围</li><li>发送方和接收方缓存多个分组</li><li>解决差错恢复问题——<strong>GBN、SR协议</strong></li></ul></li><li><p>流水线可靠数据传输协议发送方信道利用率的公式：</p><p><span class="math display">\[U_{sender} = \frac{n \times L/R}{RTT+L/R}\]</span></p><ul><li>（最大）信道利用率就是一个传输周期内信道传输数据的时间与总时间之比。</li><li>下图可以辅助理解记忆公式：</li><li><figure><img src="https://s2.loli.net/2023/10/11/i1Eo3gC7GfJx9AX.png"alt="image.png" /><figcaption aria-hidden="true">image.png</figcaption></figure></li></ul></li></ul><h3 id="gbngo-back-n协议">4.6.1 GBN(Go-Back-N)协议</h3><p><img src="https://s2.loli.net/2023/10/03/GlOHf51DR9Yw8dk.jpg" /></p><ul><li>上图展示了在GBN发送方看到的序号<ul><li>send_base：最早未确认分组的序号</li><li>nextseqnum：下一个待发送分组的序号</li><li>N：已发送但未确认分组的序号范围，可看做长度为N的窗口。</li></ul></li><li>GBN发送方扩展FSM如下图所示 <imgsrc="https://s2.loli.net/2023/10/03/TmEl5cHA6etu241.jpg" /></li><li>GBN发送方必须响应3种类型的事件<ul><li><strong>上层调用</strong>。当上层调用rdt_send()时，发送方首先检查窗口是否已满（是否有N个已发送未确认的分组）。若窗口未满，则产生产生一个分组并发送。</li><li><strong>收到ACK</strong>。GBN协议对序列号为n的分组的确认采用<strong>累计确认</strong>的方式，即表明接收方已经正确接收到序列号为n以及它以前的所有分组。</li><li><strong>超时事件</strong>。GBN协议仅为最早的已发送但未确认的分组设置定时器。如果出现超时，GBN<strong>重传所有已发送未确认的分组</strong>。</li></ul></li><li>GBN接收方的扩展FSM如下图所示 <imgsrc="https://s2.loli.net/2023/10/03/bBqwXaO9ctr2LyV.jpg" /><ul><li>如果接收方按序收到分组，那么为该分组发送一个ACK，并将分组中的数据提交给上层</li><li>GBN协议直接丢弃乱序到达的分组，重新发送序列号最大的、按序到达的分组的ACK</li></ul></li><li>GBN协议示例 <imgsrc="https://s2.loli.net/2023/10/03/sLxebiftHNYoV8d.jpg" /></li></ul><h3 id="srselective-repeat协议">4.6.2 SR(Selective Repeat)协议</h3><p><img src="https://s2.loli.net/2023/10/03/jP4v3uONGgUIFVC.png" /></p><ul><li><p>上图展示了SR发送方和接收方的序号空间</p><ul><li>接收方对每个分组单独进行确认<ul><li>设置缓存机制，缓存乱序到达的分组，而非丢弃</li></ul></li><li>为每个分组设置定时器，只重传那些没收到ACK的分组</li><li>发送方和接收方同样都有大小为N的窗口长度</li></ul></li><li><p>SR协议发送方行为</p><ul><li>从上层收到数据。发送方首先检查下一个可用于该分组的序号。若在窗口内，则将数据打包发送，类似于GBN。</li><li>超时。每个分组拥有自己的定时器。超时发生则重传超时的分组。</li><li>收到ACK。将收到ACK的分组标记为已收到。若序号为send_base，则窗口的send_base向前移动到具有最小序号的未确认分组处</li></ul></li><li><p>SR协议接收方行为</p><ul><li>接收到序号在[rcvbase,rcvbase+N-1]的分组：发送ACK<ul><li>乱序：缓存该分组</li><li>若序列号为rcvbase，则把改分组以及以前缓存的序号连续的分组一起交付给上层。</li></ul></li><li>序列号在[rcvbase-N,rcvbase-1]<ul><li>发送ACK</li></ul></li><li>其他情况忽略掉 下图是SR协议的一个示例 <imgsrc="https://s2.loli.net/2023/10/03/ekofE4DmMWgvSbz.png" /></li></ul></li><li><p>序列号空间大小与窗口尺寸的关系：</p><p><span class="math display">\[N_s +N_r \leq 2^L\]</span></p><ul><li><span class="math inline">\(N_s\)</span>：发送方窗口大小</li><li><span class="math inline">\(N_r\)</span>：接收方窗口大小</li><li><span class="math inline">\(L\)</span>：序列号比特数</li></ul><blockquote><p>GBN协议中，接收方窗口大小为1。</p></blockquote></li></ul><h1 id="面向连接传输协议tcp">5.面向连接传输协议：TCP</h1><h2 id="tcp概述">5.1 TCP概述</h2><ul><li>TCP被称为<strong>面向连接的</strong><ul><li>一个应用进程可以开始向另一个应用进程发送数据之前，这两个进程必须握手，即相互发送预备报文段，确保数据传输的参数</li></ul></li><li>TCP连接提供的是<strong>全双工服务</strong><ul><li>同一连接中可以传输双向数据流</li></ul></li><li>TCP连接是点对点的，是在单个发送方和单个接收方之间的连接。</li><li>TCP连接的组成包括：两台主机上的缓存、变量和与进程连接的套接字</li><li>TCP报文段结构如下图所示 <imgsrc="https://s2.loli.net/2023/10/03/EKgum17eXFWyTws.png" /></li><li>TCP报文段的序列号<ul><li>序列号是报文段首字节的字节流编号，不是报文段的编号</li><li>建立TCP连接时，双方随机选择序列号</li></ul></li><li>TCP的确认号<ul><li>期望接收到的下一个字节的序列号</li><li>TCP提供<strong>累计确认</strong>：该序列号之前的所有字节均已被正确接收到</li></ul></li></ul><h2 id="tcp可靠数据传输">5.2 TCP可靠数据传输</h2><ul><li>TCP使用流水线机制、累计确认的方式，并且使用单一重传计时器。在超时或者收到重复ACK会重传报文段</li><li>TCP连接RTT的估计<ul><li>参考RTT可以设置定时器的超时时间。<ul><li>超时时间需要大于RTT，但大于RTT会对段丢失的反应时间较慢</li><li>超时时间若小于RTT，会造成不必要的重传</li></ul></li><li>TCP为一个已发送的但目前尚未确认的报文段估计一个SampleRTT，测量多次SampleRTT，求平均值，形成RTT估计值EstimatedRTT</li><li>测量RTT的变化值，即SampleRTT与EstimatedRTT的差值，得到DevRTT。</li><li>超时时间设置为EstimatedRTT+4*DevRTT</li></ul></li><li>TCP发送方事件<ul><li>创建Segment</li><li>序列号是Segment第一个字节的编号</li><li>开启计时器</li><li>设置超时时间</li><li>若计时器超时<ul><li>重传引起超时的Segment</li><li>重启定时器</li></ul></li><li>收到ACK<ul><li>如果确认此前未确认的Segment，更新SendBase，滑动窗口向前滑动</li><li>如果窗口中还有未被确认的分组，重新启动定时器</li></ul></li></ul></li><li>下面展示了TCP进行重传的示例 <imgsrc="https://s2.loli.net/2023/10/03/T345mEV9dZvMh7c.png" /> <imgsrc="https://s2.loli.net/2023/10/03/KguUGFYwVlZDAas.png" /></li><li>接收方产生 ACK 的事件<ul><li>所期望序号的按需报文段已经到达，且以前的数据都已经ACKed<ul><li>延迟发送ACK，最多等待500ms，如果在这期间没有一个按序报文段到达，则发送一个ACK</li></ul></li><li>所期望序号的按需报文段已经到达，且有一个按序报文段等待ACK传输<ul><li>发送单个累计确认ACK，确认两个按序报文段</li></ul></li><li>比期望序号大的失序报文段到达<ul><li>发送冗余ACK（再次确认某个报文段的ACK，发送方先前已收到）</li></ul></li><li>能部分或完全填充接受数据间隔的报文段到达<ul><li>该报文段若起始于间隔的低端，则立即发送ACK</li></ul></li></ul></li><li>快速重传机制<ul><li>如果分组丢失而发生超时，超时时间间隔将重新设置为原来的两倍，使得重发丢失的分组之前要等待很长时间，故建立快速重传机制</li><li>快速重传机制——通过重复ACK判断分组丢失<ul><li>发送方以流水线方式一个接一个地发送大量报文段，如果某个分组丢失，可能会引发多个冗余ACK</li><li>发送方收到同一数据的3个ACK，就执行快速重传，即在该报文段定时器过期之前就重传丢失的报文段</li></ul></li></ul></li></ul><h2 id="tcp流量控制">5.3TCP流量控制</h2><ul><li>接收方为TCP连接分配buffer，进行流量控制可以使得发送方不会传输过多过快，导致buffer溢出</li><li>流量控制机制<ul><li>发送方维护一个接收窗口(rwnd)的变量，指示接收方还有多少可用的缓存空间<ul><li>接受窗口计算：RcvWindow = RcvBuffer-[LastByteRcvd - LastByteRead]<ul><li>LastByteRcvd：到达并放入接收方缓存中的数据流的最后一个字节的编号</li><li>LastByteRead：接收方从缓存中读出的数据流中最后一个字节的编号</li></ul></li></ul></li><li>接收方通过在报文段的头部字段将Rcvwindow告诉发送方</li><li>发送方限制自己已经发送的但还未收到ACK的数据不超过接收方的空闲RcvWindow尺寸</li></ul></li></ul><h2 id="tcp连接管理">5.4 TCP连接管理</h2><ul><li>TCP连接创建过程被称作三次握手<ol type="1"><li>客户端TCP首先向服务器端的TCP发送一个SYN报文段。该报文段不包含数据且SYN置为1，客户端随机选择初始序列号。</li><li>服务器收到SYN报文段，为该TCP连接分配TCP缓存和变量，并向该客户TCP发送SYNACK报文段。其中SYN置为1</li><li>客户端收到SYNACK报文段，向服务器发送一个报文段，这对服务器允许连接的报文段进行确认。客户端发送的报文段可以写到客户到服务器的数据。<img src="https://s2.loli.net/2023/10/03/N6qisAxzaDmuEj7.png" /></li></ol></li><li>TCP关闭连接的过程又被称为四次挥手<ol type="1"><li>客户端向服务器发送时带有FIN比特置为1的TCP报文段，并进入FIN_WAIT_1状态</li><li>服务器收到FIN报文段，回复ACK。关闭连接，发送FIN报文段</li><li>客户机收到ACK，进入FIN_WAIT_2状态。接着客户机收到FIN报文段，进入TIME_WAIT状态，向服务器发送ACK</li><li>服务器收到ACK，连接正式关闭 <imgsrc="https://s2.loli.net/2023/10/03/DRmSN2dGyu9Pqo4.png" /></li></ol></li></ul><h2 id="tcp拥塞控制">5.5 TCP拥塞控制</h2><ul><li>设置<strong>拥塞窗口</strong>变量cwnd动态调整以改变发送速率</li></ul><p><span class="math display">\[$LastByteSent-LastByteAcked ≤ \{cwnd，rwnd \}\]</span></p><p><span class="math display">\[$rate \approx \frac{cwnd}{RTT} Bytes/sec\]</span></p><ul><li>发生Loss事件（timeout或3个冗余ACK）后，发送方降低速率</li><li>加性增——乘性减（AIMD）<ul><li>每个RTT内cwnd线性增加一个MSS（最大段长度），线性增加拥塞窗口长度</li><li>出现Loss事件后，将cwnd减半 <imgsrc="https://s2.loli.net/2023/10/03/74KzAUmxadQvMNn.png"alt="image.png" /></li></ul></li><li>慢启动（SS）<ul><li>TCP连接开始时，cwnd=1</li><li>每当确认一个报文段，cwnd加1</li><li>慢启动阶段拥塞窗口指数级增长</li><li>定义状态变量ssthresh（慢启动阈值）。<ul><li>当检测到拥塞时（发生Loss事件），将ssthresh设置为拥塞窗口的一半。</li><li>当cwnd由慢启动状态增长到达或超过ssthresh时，结束慢启动状态 <imgsrc="https://s2.loli.net/2023/10/03/IEF9zpNXQj6OrlG.png"alt="image.png" /></li></ul></li></ul></li><li>Loss事件处理<ul><li>3个冗余ACKs<ul><li>cwnd变为原来的一半</li><li>然后线性增长</li></ul></li><li>Timeout事件<ul><li>cwnd直接设为1个MSS</li><li>然后指数增长</li><li>达到ssthresh后,再线性增长</li></ul></li></ul></li><li><strong>总结</strong><ul><li>当拥塞窗口低于ssthresh时，发送方以慢启动状态使得拥塞窗口指数增长</li><li>当拥塞窗口超过ssthresh时，发送方进入拥塞避免状态，拥塞窗口线性增长</li><li>3个冗余ACK出现时，ssthresh设置为拥塞窗口的一半，拥塞窗口设置为新的ssthresh</li><li>超时事件发生时，ssthresh设置为拥塞窗口的一半，拥塞窗口设置为1</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络笔记(2)——应用层</title>
    <link href="/2023/10/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0-2-%E2%80%94%E2%80%94%E5%BA%94%E7%94%A8%E5%B1%82/"/>
    <url>/2023/10/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0-2-%E2%80%94%E2%80%94%E5%BA%94%E7%94%A8%E5%B1%82/</url>
    
    <content type="html"><![CDATA[<h1 id="网络应用的基本原理">1.网络应用的基本原理</h1><h2 id="网络应用的体系结构">1.1 网络应用的体系结构</h2><ul><li>客户机/服务器结构（Client-Server,C/S）<ul><li>服务器<ul><li>永远在线，提供服务</li><li>永久性访问地址</li><li>利用大量服务器实现可扩展性</li></ul></li><li>客户机<ul><li>与服务器通信，使用服务器提供的服务</li><li>间歇性接入网络</li><li>可能使用动态IP地址</li><li>不会和其他客户机直接通信</li></ul></li></ul></li><li>P2P结构<ul><li>没有永远在线的服务器</li><li>任意端系统之间可以直接通讯</li><li>节点间歇性接入网络</li><li>节点可能改变IP地址</li></ul></li><li>混合结构<ul><li>例如：Napster<ul><li>文件传输使用P2P结构</li><li>文件搜索使用C/S结构</li></ul></li></ul></li></ul><h2 id="网络应用进程通信">1.2 网络应用进程通信</h2><ul><li>在两个不同端系统的进程，通过跨越计算机网络交换报文而相互通信<ul><li>客户机进程：发起通信的进程</li><li>服务器进程：等待通信请求的进程</li></ul></li><li>进程通过一个称为socket的软件接口向网络发送报文和从网络接受报文 <imgsrc="https://images.cnblogs.com/cnblogs_com/blogs/797656/galleries/2343007/o_230910152149_network10.png"alt="img" /></li><li>进程寻址<ul><li>IP地址：32位比特的量且能唯一标识主机</li><li>端口号：标识主机上每个需要通信的进程<ul><li>HTTP Server：80</li><li>Mail Server：25</li></ul></li><li>进程的标识符：IP地址+端口号</li></ul></li></ul><h2 id="可供网络应用使用的传输服务">1.3 可供网络应用使用的传输服务</h2><ul><li>可靠数据传输<ul><li>要求100%可靠的数据传输的应用：文件传输</li><li>能够容忍一定的数据丢失的应用：网络电话</li></ul></li><li>吞吐量<ul><li>带宽敏感的应用：多媒体应用</li><li>弹性应用：根据当时可用的带宽或多或少第利用可供使用的吞吐量。<ul><li>电子邮件、文件传输、Web传送等</li></ul></li></ul></li><li>定时<ul><li>网络电话、网络游戏等实时的应用需要足够低的时延</li></ul></li><li>安全性<ul><li>运输协议能够加密有发送进程传输的所有数据，在接收主机中，运输协议能够再将数据交付给接收进程之前解密这些数据</li></ul></li></ul><h2 id="internet-提供的传输服务">1.4 Internet 提供的传输服务</h2><ul><li>TCP服务<ul><li>面向连接：客户机/服务器进程间需要建立TCP连接</li><li>可靠的数据传输服务</li><li>流量控制：发送方不会发送速度过快、超过接收方的处理能力</li><li>拥塞控制：当网络负载过重时，能够限制发送方的发送速度</li></ul></li><li>UDP服务<ul><li>无连接：两个进程通信前没有握手过程。</li><li>不可靠的数据传输</li><li>不提供拥塞控制、流量控制</li></ul></li></ul><h1 id="web应用">2.Web应用</h1><h2 id="http概述">2.1 HTTP概述</h2><ul><li>Web应用遵循HTTP协议，采用客户机/服务器结构<ul><li>客户———Browser：请求、接收、展示Web对象</li><li>服务器————Web Server：相应客户的请求，发送对象</li></ul></li><li>HTTP使用TCP作为它的支撑运输协议<ul><li>服务器在80端口等待客户的请求</li><li>浏览器发起到服务器的TCP连接（创建套接字Socket）</li><li>服务器接受来自浏览器的TCP连接</li><li>浏览器(HTTP客户端)与Web服务器（HTTP服务器）交换HTTP信息</li><li>关闭TCP连接</li></ul></li><li>HTTP是无状态协议，并不保存关于客户的任何信息</li></ul><h2 id="http连接类型">2.2 HTTP连接类型</h2><ul><li>非持久性连接<ul><li>每个TCP连接最多允许传输一个对象</li><li>HTTP1.0版本使用非持久性连接</li></ul></li><li>非持久性连接情况下传送Web页面的步骤（假定URL为www.someSchool.edu/someDepartment/home.index）<ul><li>HTTP客户进程在端口号80发起一个到服务器www.someSchool.edu的TCP连接请求，HTTP服务器在端口80等待TCP连接请求，接受连接并通知客户端</li><li>HTTP客户端将HTTP请求消息（包含URL）通过TCP连接的套接字发出</li><li>HTTP服务器收到请求消息，解析，产生包含所需要对象的相应消息，并通过套接字发给客户端</li><li>HTTP服务器关闭TCP连接</li><li>HTTP客户端收到相应消息，解析并显示html文件，发现有10个执行jpeg对象的超链接</li><li>为每个jpeg对象重复以上步骤</li></ul></li><li>往返时间（RTT）：一个短分组从客户到服务器然后再返回客户所花费的时间</li><li>非持久性连接的响应时间<ul><li>发起、建立TCP连接：1个RTT</li><li>发送HTTP请求消息到HTTP相应消息的前几个字节到达：1个RTT</li><li>总时间=2*RTT + 文件发送时间 <imgsrc="https://images.cnblogs.com/cnblogs_com/blogs/797656/galleries/2343007/o_230910164005_network11.png"alt="img" /></li></ul></li><li>持久性连接<ul><li>每个TCP连接允许传输多个对象</li><li>发送响应后，服务器保持TCP连接打开，后续的HTTP消息可以通过这个连接发送</li><li>HTTP1.1版本默认使用持久性连接</li></ul></li><li>无流水的持久性连接<ul><li>客户端只有收到前一个相应后才发送新的请求</li><li>每个被引用的对象耗时1个RTT</li></ul></li><li>带有流水机制的持久性连接<ul><li>客户端只要遇到一个引用对象就尽快地发出请求</li><li>理想情况下，收到所有的引用对象只需耗时约1个RTT</li><li>HTTP 1.1的默认选项</li></ul></li></ul><h2 id="http消息格式">2.3 HTTP消息格式</h2><ul><li>HTTP请求消息<ul><li>由普通ASCII书写，人直接可读</li><li>请求消息的第一行叫做请求行(request line)<ul><li>方法字段————GET,POST,HEAD,PUT,DELETE</li><li>URL字段</li><li>HTTP字段</li></ul></li><li>请求行后继的行叫做首部行（header line）<ul><li>Host:对象所在的主机</li><li>Connection：是否使用持续连接</li><li>User-agent：指明用户代理</li></ul></li><li>实体体（entity body）————使用POST方法时才使用 <imgsrc="https://images.cnblogs.com/cnblogs_com/blogs/797656/galleries/2343007/o_230911090917_network12.png"alt="img" /></li></ul></li><li>HTTP响应消息<ul><li>响应消息第一行为初始状态行（status line）<ul><li>协议版本字段</li><li>状态码和状态信息<ul><li>200 OK：请求成功，信息在返回的响应报文中</li><li>301 Moved Permanently：请求的对象被永久转移</li><li>400 Bad Request：该请求不能被服务器理解</li><li>404 Not Found：被请求的文档不在服务器上</li><li>505 HTTP Version NotSupported：服务器不支持请求报文使用的HTTP版本</li></ul></li></ul></li><li>初始状态行后继的行叫做首部行（header line）</li><li>实体体是响应消息的主要部分，包含了所请求的对象本身 <imgsrc="https://images.cnblogs.com/cnblogs_com/blogs/797656/galleries/2343007/o_230911110610_network13.png"alt="img" /></li></ul></li></ul><h2 id="cookie技术">2.4 Cookie技术</h2><ul><li>某些网站为了辨别用户身份、进行session跟踪而存储在用户本地终端上的数据</li><li>Cookie的组件<ul><li>HTTP相应消息的cookie头部行</li><li>HTTP请求消息的cookie头部行</li><li>保存在客户端主机上的cookie文件，由浏览器管理</li><li>Web服务器端的后端数据库</li></ul></li><li>Cookie技术支持<ul><li>身份认证</li><li>构建购物车</li><li>个性化推荐</li><li>用户会话状态信息维护</li></ul></li></ul><h2 id="web缓存技术">2.5 Web缓存技术</h2><ul><li>功能：在不访问服务器的前提下满足客户端的HTTP请求</li><li>Web缓存技术的优势：<ul><li>缩短客户请求的相应时间</li><li>减少机构的流量</li><li>在大范围内实现有效的内容分发</li></ul></li><li>Web缓存服务器（代理服务器）<ul><li>用户通过配置使得所有的HTTP请求首先指向Web缓存服务器<ul><li>如果请求对象在缓存中，缓存返回对象</li><li>否则，缓存服务器向原始服务器发送HTTP请求来获取对象，然后返回客户端并保存该对象</li></ul></li><li>Web缓存器既是服务器又是客户，一般由ISP假设</li></ul></li><li>条件GET方法<ul><li>一种允许缓存器证实它的对象是最新的机制</li><li>缓存器向Web服务器发送的请求消息中声明所持有版本的日期</li><li>如果缓存的版本是最新的，则响应消息不包含对象</li></ul></li></ul><h1 id="email应用">3.Email应用</h1><ul><li>Email应用的组成部分<ul><li>用户代理（user agent）<ul><li>允许用户阅读、回复、转发、保存和撰写报文</li><li>例如：Outlook、Apple Mail、Gmail等</li></ul></li><li>邮件服务器<ul><li>有一个邮箱，管理和维护该用户的Email</li><li>消息队列：存储等待发送的Email，如果邮件不能够交付给接收方的服务器上，就会在消息队列中保持该消息并在以后的尝试中发送</li></ul></li><li>简单邮件传输协议（Simple Mail Transfer Protocol,SMTP）</li></ul></li><li>SMTP协议<ul><li>使用TCP协议进行Email消息的可靠传输</li><li>端口号：25</li><li>Email消息只能抱哈7位ASCII码</li><li>命令/响应交互模式<ul><li>命令：ASCII文本</li><li>响应：状态代码和语句</li></ul></li><li>使用持久性连接</li></ul></li><li>Email消息格式<ul><li>头部行（header）<ul><li>必须包括From和To首部行</li><li>也许包含一个Subject首部行</li></ul></li><li>消息体（body）<ul><li>只能是ASCII字符</li></ul></li></ul></li></ul><figure><img src="https://s2.loli.net/2023/10/03/dGScBOveY7s6HkL.png"alt="image.png" /><figcaption aria-hidden="true">image.png</figcaption></figure><ul><li>邮件访问协议</li></ul><figure><img src="https://s2.loli.net/2023/10/03/69B1nW4epaRMrmH.png"alt="image.png" /><figcaption aria-hidden="true">image.png</figcaption></figure><ul><li>POP协议<ul><li>采用“下载并删除”模式。用户如果更换客户端软件，则无法重读该邮件</li><li>采用“下载并保持”模式。不同客户端都可以保留消息的拷贝</li><li>无状态</li></ul></li><li>IMAP协议<ul><li>所有消息统一保存在服务器</li><li>允许用户利用文件夹组织信息</li></ul></li><li>HTTP协议也可以作为邮件访问协议</li></ul><h1 id="dns应用">4.DNS应用</h1><h2 id="dns概述">4.1 DNS概述</h2><ul><li>DNS(Domain NameSystem):域名解析系统，提供主机名到IP地址转换的目录服务。<ul><li>组成<ul><li>一个分层的DNS服务器实现的分布式数据库</li><li>一个应用层协议：使得主机能够查询分布式数据库</li></ul></li><li>若采用集中式的DNS，会产生问题如下：<ul><li>单点故障：如果该DNS服务器崩溃，整个因特网随之瘫痪</li><li>通信容量：单个服务器不得不处理所有的DNS查询</li><li>远距离的集中式数据库：若DNS服务器放在亚洲，那么对于其他国家的DNS查询需要传播到地球另一端，也许需要经过低速和拥挤的链路，时延会很长</li><li>维护问题：单个DNS服务器必须为所有的因特网主机保留记录，会产生很大的维护开销。</li></ul></li></ul></li><li>DNS服务<ul><li>域名到IP地址的转换</li><li>主机别名：具有复杂主机名的主机可能有多个别名。应用程序可以调用DNS获取主机别名对应的规范主机名以及主机的IP地址</li><li>邮件服务器别名：邮件应用程序调用DNS获取主机别名对应的规范主机名及其IP地址</li><li>负载分配：DNS用于在冗余的服务器进行负载分配</li></ul></li></ul><h2 id="dns工作机理">4.2 DNS工作机理</h2><ul><li>根DNS服务器、顶级域（TLD）DNS服务器、权威DNS服务器按照下图的层次结构组织。<ul><li>客户端想要查询www.amazon.com的IP，需要进行下列步骤（1）客户端与根服务器联系，返回顶级域名com的TLD服务器的IP地址（2）客户端与com域名解析服务器联系，返回权威服务器的IP地址（3）客户端与amazon.com的权威服务器之一联系，获得www.amazon.com的IP地址<img src="https://s2.loli.net/2023/10/03/cMzo8nNFxZW4GPQ.png"alt="image.png" /></li></ul></li><li>本地DNS服务器<ul><li>不严格属于该服务器的层次结构</li><li>每一个ISP都有一台本地DNS服务器</li><li>主机发出DNS请求时，查询被发送到本地DNS服务器，起着代理的作用，并将该请求转发到DNS服务器的层次结构中。</li></ul></li><li>迭代查询 <imgsrc="https://s2.loli.net/2023/10/03/rC2LR54JZAlXhS7.png"alt="image.png" /></li><li>递归查询 <imgsrc="https://s2.loli.net/2023/10/03/sLqWfbCUdN92tGJ.png"alt="image.png" /></li><li>DNS缓存<ul><li>在一个请求链中，当某DNS服务器接收一个DNS回答时，它就能将映射缓存在本地存储器中。</li></ul></li></ul><h2 id="dns记录和消息">4.3 DNS记录和消息</h2><ul><li><p>资源记录（ResourceRecord,RR）：存储于共同实现DNS分布式数据库的所有DNS服务器中，是一个包含下列字段的4元组<span class="math display">\[(Name,Value,Type,TTL)\]</span></p><ul><li>如果Type=A<ul><li>Name：主机域名</li><li>Value：主机名对应的IP地址</li></ul></li><li>如果Type=NS<ul><li>Name：域（foo.com）</li><li>Value：该域权威域名解析服务器的主机域名</li></ul></li><li>如果Type=CNAME<ul><li>Name：某一真实域名的别名</li><li>Value：主机别名为Name的规范主机名</li></ul></li><li>如果Type=MX<ul><li>Name：邮件服务器主机名的别名</li><li>Value：别名为Name的邮件服务器的规范主机名</li></ul></li></ul></li><li><p>DNS消息格式</p></li></ul><figure><img src="https://s2.loli.net/2023/10/03/iHV2naJwmLQk9Is.png"alt="image.png" /><figcaption aria-hidden="true">image.png</figcaption></figure><h1 id="p2p应用">5.P2P应用</h1><h2 id="p2p文件分发">5.1 P2P文件分发</h2><ul><li><p>客户机-服务器体系结构的文件分发时间</p><ul><li><p>服务器必须向N个对等方的每一个传输该文件的一个副本，一共需要传输<spanclass="math inline">\(NF\)</span> bit，由于上载速率是<spanclass="math inline">\(u_s\)</span>，分发该文件的时间至少是 <spanclass="math inline">\({NF}/{u_s}\)</span></p></li><li><p>令 <spanclass="math inline">\(d_{min}\)</span>为具有最小下载速率的对等方的下载速率。易知最小分发时间至少为<spanclass="math inline">\({F}/{d_{min}}\)</span></p></li><li><p>把文件分发给对等方的时间为： <span class="math display">\[D_{cs}=\max \{ \frac {NF}{u_s},\frac{F}{d_{min}} \}\]</span></p><ul><li>对于足够大的N，客户机服务器分发时间随着对等方数量增加而线性地增大</li><li>注：其中<spanclass="math inline">\(u_s\)</span>表示服务器接入链路的上载速率，<spanclass="math inline">\(F\)</span>表示分发的文件长度（bit），<spanclass="math inline">\(u_i\)</span>表示第i个对等方接入链路的上载速率，<spanclass="math inline">\(d_i\)</span>表示第i个对等方接入链路的下载速率，<spanclass="math inline">\(N\)</span>表示数量，下同。</li></ul></li></ul></li><li><p>P2P文件分发时间</p><ul><li>服务器必须至少发送文件一次，所需时间为 <spanclass="math inline">\({F}/{u_s}\)</span></li><li>对等方下载所需时间至少为拥有最小下载速度的对等方的下载时间 <spanclass="math inline">\({F}/{u_{min}}\)</span></li><li>系统整体总上载能力为 <spanclass="math inline">\(u_{total}=u_s+u_1+u_2+...+u_N\)</span>。系统必须向每一个对等方上载<spanclass="math inline">\(F\)</span>bit，时间至少为 $ {NF}/{u_{total}}$</li><li>综上所述，P2P最小分发时间为 <span class="math display">\[D_{P2P} = \max {\{} {\frac{F}{u_s} {,} \frac {F}{u_{min}},\frac{NF}{\sum_{i=1}^N u_i} {\}}}\]</span></li></ul></li><li><p>BitTorrent</p><ul><li>一种用于文件分发的流行P2P协议</li><li>洪流（torrent）：参与一个特定文件分发的所有对等方的集合</li><li>一个洪流中的对等方彼此下载等长度的文件块（chunk），典型的块长度为256KB</li><li>对等方加入某洪流<ul><li>没有块，但会逐渐积累</li><li>向追踪器（tracker）注册获得节点清单，与对等方建立连接</li></ul></li><li>下载的同时，结点需要向其他对等方上传块</li><li>获取块——最稀缺优先<ul><li>针对自己没有的块在邻居中找最稀缺的块（邻居中副本最少的块），首先进行请求</li><li>大致均衡洪流中的副本数量</li></ul></li><li>发送块——一报还一报（tit-for-tat）<ul><li>根据当前能够以最高速率向她提供数据的邻居，给予其优先权<ul><li>确定以最高数据流入的4个邻居，即确定疏通（unchoked）</li><li>每10s重新计算速率以重新确定疏通</li></ul></li><li>每30s随机选择一个其他邻居并向其发送块</li></ul></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络笔记(1)——计算机系统概述</title>
    <link href="/2023/10/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0-1-%E2%80%94%E2%80%94%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/"/>
    <url>/2023/10/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0-1-%E2%80%94%E2%80%94%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="计算机网络">1.计算机网络</h2><ul><li>计算机网络是<strong>互联</strong>的、<strong>自治</strong>的计算机集合。<ul><li>自治——无主从关系</li><li>互联——互联互通</li></ul></li><li>端系统（主机）通过通信链路和分组交换机的网络连接到一起。常见的分组交换机的类型是路由器和链路层交换机。</li><li>端系统通过因特网服务提供商（Internet ServiceProvider,ISP）接入因特网</li></ul><h2 id="网络协议">2.网络协议</h2><ul><li>网络协议(networkprotocol),简称为协议，是为进行网络中的数据交换而建立的规则、标准或约定。</li><li>协议定义了在两个或多个通信实体之间交换的报文的格式和顺序，以及报文的发送/接收或其他事件所采取的操作。</li><li>协议的三要素<ul><li>语法（Syntax）<ul><li>数据与控制信息的结构或格式</li><li>信号电平</li></ul></li><li>语义（Semantics）<ul><li>需要发出何种控制信息</li><li>完成何种动作以及做出何种响应</li><li>差错控制</li></ul></li><li>时序（Timing）<ul><li>事件顺序</li><li>速度匹配</li></ul></li></ul></li></ul><h2 id="计算机网络结构">3.计算机网络结构</h2><h3 id="网络边缘">3.1 网络边缘</h3><ul><li>端系统（主机）位于“网络边缘”，运行应用程序，如web，Email等。</li></ul><h3 id="接入网络">3.2 接入网络</h3><ul><li>接入网：将端系统物理连接到其边缘路由器的网络。<ul><li>家庭接入网络</li><li>机构接入网络</li><li>移动接入网络</li></ul></li><li>家庭接入网络<ul><li>数字用户线路（DSL）<ul><li>每个用户的DSL调制调节器使用现有的电话线与位于电话公司的本地中心局中的DSL接入多路复用器交换数据。</li><li>频分多路复用：在不同频带上传输不同频道<ul><li>高速下行信道：50kHz~1MHz频段</li><li>中速上行信道：4kHz~50kHz频段</li><li>普通的双向电话信道：位于0~4kHz频段 <imgsrc="https://images.cnblogs.com/cnblogs_com/blogs/797656/galleries/2343007/o_230910072650_network1.png"alt="img" /></li></ul></li></ul></li><li>电缆网络<ul><li>非对称：下行高达30Mbps传输速率，上行为2Mbps传输速率。</li><li>各个家庭共享家庭至电缆头端的接入网络，而DSL独占至中心局接入 <imgsrc="https://images.cnblogs.com/cnblogs_com/blogs/797656/galleries/2343007/o_230910073919_network2.png"alt="img" /></li></ul></li></ul></li><li>机构接入网络<ul><li>典型传输速率：10Mbps,100Mbps,1Gbps,10Gbps</li><li>端系统通常直接连接以太网交换机 <imgsrc="https://images.cnblogs.com/cnblogs_com/blogs/797656/galleries/2343007/o_230910074359_network3.png"alt="img" /></li></ul></li><li>无线接入网络<ul><li>无线局域网（LANS）</li><li>广域无线接入（4G,5G）</li></ul></li></ul><h3 id="网络核心">3.3 网络核心</h3><ul><li>网络核心：由互联因特网端系统的分组交换机和链路构成的网状网络。</li><li>关键功能:<ul><li>路由：确定分组从源到目的传输路径</li><li>转发：将分组从路由器的输入端口交换至正确的输出端口</li></ul></li><li>通过数据交换的方式，实现数据通过网络核心从源主机到达目的主机的过程<imgsrc="https://images.cnblogs.com/cnblogs_com/blogs/797656/galleries/2343007/o_230910083124_network4.png"alt="img" /><ul><li>端系统通过接入ISP连接到Internet</li><li>一级ISP（如网通，电信）提供国家或国际范围的覆盖</li><li>多个ISP在因特网交换点（Internet ExchangePoint,IXP）对等（peer）</li><li>内容提供商网络(content providernetwork,如：Google)：私有网络，连接其数据中心与Internet，通常绕过一级ISP和区域ISPs</li></ul></li></ul><h2 id="数据交换">4.数据交换</h2><h3 id="电路交换">4.1 电路交换</h3><ul><li>电路交换的三个阶段<ul><li>建立连接（呼叫/电路建立）</li><li>通信</li><li>释放连接（拆除电路）</li></ul></li><li>电路交换网络中，端系统间通信独占一份网络资源，通过多路复用共享中继线。</li><li>多路复用（Mutiplexing）：将网络资源划分为“资源片”，分配给各路“呼叫”，每路呼叫独占分配到的资源。资源片可能“闲置”（idle）。<ul><li>频分多路复用（FDM）：各个用户占用不同的频率带宽资源。 <imgsrc="https://images.cnblogs.com/cnblogs_com/blogs/797656/galleries/2343007/o_230910090935_network5.png"alt="img" /></li><li>时分多路复用（TDM）：将时间划分为一段段等长的时分复用帧（TDM帧），每个用户在每个TDM帧中占用固定序号的时隙<imgsrc="https://images.cnblogs.com/cnblogs_com/blogs/797656/galleries/2343007/o_230910091246_network6.png"alt="IMG" /></li></ul></li></ul><h3 id="报文交换与分组交换">4.2 报文交换与分组交换</h3><ul><li><p>报文：应用发送的信息整体。</p><ul><li>报文交换将报文整体从源端系统发送至目的端系统</li></ul></li><li><p>分组：报文分拆出来的一系列较小的数据包</p><ul><li>分组交换将报文拆分为较小的数据块，将其传输至目的端系统。</li><li>报文的拆分与重组会产生额外开销。</li></ul></li><li><p>统计多路复用 <imgsrc="https://images.cnblogs.com/cnblogs_com/blogs/797656/galleries/2343007/o_230910092507_network7.png"alt="img" /></p><ul><li>A和B主机同时进行数据传输，传输到路由器时分组序列不确定，按需共享链路，即统计多路复用（Statisticalmultiplexing）。</li></ul></li><li><p>存储-转发交换方式：交换机开始向输出链路传输该分组的第一个比特前，必须接收到整个分组。</p><ul><li>报文交换以完整报文进行“存储-转发”</li><li>分组交换以较小的分组进行“存储-转发”</li><li>分组交换可以实现路由器转发的流水，时延更短</li></ul></li><li><p>分组交换的报文交付时间 <span class="math display">\[T = \frac{M}{R}+ \frac{nL}{R}\]</span></p><ul><li>报文：<span class="math inline">\(M\)</span> bits</li><li>链路带宽：<span class="math inline">\(R\)</span> bps</li><li>分组长度：<span class="math inline">\(L\)</span> bit</li><li>路由器数：<span class="math inline">\(n\)</span></li></ul></li><li><p>分组交换 vs 电路交换</p><ul><li>分组交换允许更多用户同时使用网络，资源充分共享</li><li>分组交换可能产生拥塞————分组延迟、丢失</li><li>分组交换使用于突发数据传输网络</li></ul></li></ul><h2 id="计算机网络性能">5. 计算机网络性能</h2><h3 id="速率带宽延迟">5.1 速率、带宽、延迟</h3><ul><li>速率即数据率，也称为数据传输速率（比特率），表示单位时间传递信息（比特）量。<ul><li>比特率是计算机网络中最重要的一个性能指标</li><li>单位b/s（bps），kb/s，Mb/s，Gb/s</li></ul></li><li>带宽：数字信道所能传送的最高数据率，单位：b/s(bps)</li><li>延迟<ul><li>节点处理延迟：<span class="math inline">\(d_{proc}\)</span>（nodalprocessing delay）<ul><li>检查分组首部并决定该分组将导向何处</li><li>检查比特级的差错</li><li>数量级在微秒甚至更低</li></ul></li><li>排队延迟：<span class="math inline">\(d_{queue}\)</span>（queueingdelay）<ul><li>等待输出链路可用，造成排队延迟</li><li>取决于路由器拥塞程度</li><li>数量级在毫秒到微秒量级</li></ul></li><li>传输延迟：<spanclass="math inline">\(d_{trans}\)</span>(transmission delay)<ul><li>路由器将一个分组的全部比特推向链路所需要的时间</li><li>$d_{trans} = $<ul><li><span class="math inline">\(L\)</span>：分组长度（bits）</li><li><span class="math inline">\(R\)</span>：链路带宽(bps)</li></ul></li></ul></li><li>传播延迟：<span class="math inline">\(d_{prop}\)</span>（propagationdelay）<ul><li>从该链路的起点到链路的终点传播所需要的时间</li><li><span class="math inline">\(d_{prop} = \frac{d}{s}\)</span><ul><li><span class="math inline">\(d\)</span>：物理链路长度</li><li><span class="math inline">\(s\)</span>：信号传播速度</li></ul></li></ul></li><li>总延迟：$d_{nodal} = d_{proc} + d_{queue} + d_{trans} + d_{prop}$</li></ul><blockquote><p>注意区分传输延迟和传播延迟的概念</p></blockquote></li><li>流量强度：<span class="math inline">\(\frac{La}{R}\)</span><ul><li><span class="math inline">\(\frac{La}{R} \approx0\)</span>：平均片段延迟很小</li><li><span class="math inline">\(\frac{La}{R} →1\)</span>：平均排队延迟很大</li><li><span class="math inline">\(\frac{La}{R} &gt;1\)</span>：超出服务能力，平均排队延迟无限大！ <imgsrc="https://images.cnblogs.com/cnblogs_com/blogs/797656/galleries/2343007/o_230910133822_network8.png"alt="img" /></li></ul></li></ul><h3 id="时延带宽积丢包率吞吐量">5.2 时延带宽积、丢包率、吞吐量</h3><ul><li>时延带宽积：以比特为单位的链路长度 <span class="math display">\[时延带宽积 = 传播时延 \times 带宽 = d_{prop} \times R(bits)\]</span></li><li>丢包<ul><li>队列缓存容量有限</li><li>分组到达已满队列将被丢弃</li><li>丢弃分组可能有前序结点或源重发（也可能不重发）</li></ul></li></ul><p><span class="math display">\[丢包率 = \frac{丢包数}{已发分组总数}\]</span></p><ul><li>吞吐量：在发送端与接收端之间传输数据速率（b/s）</li><li>瓶颈链路：端到端路径上，限制端到端吞吐量的链路</li></ul><h2 id="五层参考模型">6.五层参考模型</h2><ul><li>应用层：各种网络应用程序及它们的应用层协议存留的地方<ul><li>FTP,SMTP,HTTP</li></ul></li><li>传输层：在应用程序端点之间传送应用层报文，即进程-进程的数据传输<ul><li>TCP,UDP</li></ul></li><li>网络层：将数据报的网络层分组从一台主机移动到另一台主机。<ul><li>IP协议、路由协议</li></ul></li><li>链路层：相邻网络元素（主机、路由器等）的数据传输<ul><li>以太网、WiFi</li></ul></li><li>物理层：比特传输</li><li>数据封装 <imgsrc="https://images.cnblogs.com/cnblogs_com/blogs/797656/galleries/2343007/o_230910144008_network9.png"alt="img" /></li></ul>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
